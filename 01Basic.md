# Basic SQL - MODE
From the Basic section, I first learned the foundational components of any SQL query. `SELECT`, `FROM`, `AS`, `LIMIT` and `WHERE`. So far, the commands are somewhat intuitive and work just like one would expect them to. 

<!-- Use Ctrl+E to insert `` -->

`SELECT` is the first command you write in a query and it is used to write which columns you’d like to select from a table or database. In case of selecting several columns, they need to be separated by commas except for the last one. If we wanted to select all columns we can just write * instead of writing them all out.

`FROM` allows the database to know from which table we want the data to be extracted from.

>[!NOTE]
>When we run a query (correctly), we get a table, but the table isn’t stored permanently in the database nor it changes anything in the underlying tables.

>[!NOTE]
>According to MODE, capitalizing commands is a convention to make queries easier to read. However, SQL will understand the queries even if they are in lowercase.

>[!NOTE]
>Another formatting convention is that columns should be named in lower case, with underscores used instead of spaces. The table name should also use underscores instead of spaces. If for some reason we want or need to have spaces in the column names, we need to refer to these columns in double quotes. 

>[!TIP]
>One reason to include spaces in names is to make them more presentable. In that case we can rename that column the moment we extract them using the command `AS`; which we place after the `SELECT` command.

The `LIMIT` command allows us to restrict how many rows an SQL query returns. Many analysts use limits as simple way to keep their queries from taking too long to return. This way we can scan the first few rows of data to get an idea of which fields we care about and want to manipulate. We place it after both `SELECT` and `FROM` commands

The `WHERE` clause allows us to filter the results based on whatever condition we want. 

Comparison Operators work very similar as in other languages such as Python. We have =, =!, >, <, ≥, and ≤. We can use these with both numerical and non-numerical values. However, if we are using an operator with values that are non-numerical we need to put the value in single quotes ‘value’. For non-numerical values, these operators filter values based on alphabetical order.

We can also perform arithmetic in SQL using the same operators as in Excel: +, -, *, /. However, in SQL we can only perform arithmetic in multiple columns from the same row; if we want to add values across multiple rows, we need to use aggregate functions. We can also chain arithmetic functions, including both column names and actual numbers. The columns that contain the arithmetic functions are called “derived” columns as they are generated by modifying the information from the underlying data. We can use parentheses to manage the order of operations.

Now, we move on to SQL Logical Operators: `LIKE`, `IN`, `BETWEEN`, `IS NULL`, `AND`, `OR`, `NOT`.

`LIKE` allows us to make similar values rather than exact ones. We use %, known as a “wildcard”, when declaring the value to compare to represent any character or set of characters. In the type of SQL that MODE uses, `LIKE` is case-sensitive, however the `ILIKE` command ignores the case when there are matching values. We can also use _ (a single underscore) to substitute for an individual character.

`IN` allows us to specify a list of values that we’d like to include in the results. We can use non-numerical values, but they need to go inside single quotes

`BETWEEN` allows us to select only rows that are within a specific range; it has to be paired with the `AND` operator. It includes the range bounds that we specify in the query, in addition to the values between them

`IS NULL` allows us to exclude rows with missing data from the results. We can select rows that contain no data in a given column by using it. Arithmetic can’t be performed on null values.

`AND`  allows us to select only rows that satisfy two conditions. It can be used with additional `AND` statements or any other comparison operator, as many times as we want. A good way to make long WHERE clause is to space the code out onto multiple lines.

`OR` allows us to select rows that satisfy either of two conditions. It works the same was as `AND`. We can combine `AND` with `OR` using parenthesis.

We can put `NOT` before any conditional statement to select rows for which the statement is false. Commonly used with `LIKE`, and also to identify non-null rows, but the syntax is different, as `IS` needs to be included beforehand,

`ORDER BY` allows us to reorder results based on the data in one or more columns. Ascending order (from a to z) is SQL default. When ordering a numerical column in ascending order, it starts with smaller (or most negative) numbers, with each successive row having a higher numerical value than the previous. To get results in the opposite order (descending order), we need to add the `DESC` operator.

We can order data by multiple columns if the data falls into categories and we’d like to organize rows by date.  First, columns in the `ORDER BY` clause must be separated by commas. Second, the `DESC` operator is only applied to the column that precedes its. Finally, the results are sorted by the first column mentioned, then by the one mentioned afterward.

We can substitute numbers for column names in the `ORDER BY` clause. The numbers will correspond to the order in which we list columns in the `SELECT` clause. However, this functionality is not supported by every flavor of SQL. When using `ORDER BY` with a row limit, the ordering clause is executed first, meaning that the results are ordered before limiting to only a few rows.

>[!NOTE]
We can add comments to our code by adding combinations of characters, such that those parts of our queries are not treated like SQL code. This is helpful to explain our thinking so we can remember what we intended to do. We use -- (two dashes) to comment out everything to the right of them on a given line.

So far SQL seem like a extremely useful to extract and analyze data. I’m curious to see what more advanced commands we can use to handle data.

## Practice Problems

Below are some practice problems I completed as part of Mode's tutorial, using real-world datasets.

For the following queries, I'll be working with real data from the U.S. Census. This dataset shows the number of completed housing units in major regions of the United States. The table I'll be working with has a column for each region. The values in each row represent the number of housing units completed in thousands during the corresponding month. The data was collected in August 2014 and can be accessed at [the U.S. Census website](http://www.census.gov/econ/currentdata/).

### SELECT
1. Write a query to select all of the columns in the tutorial.us_housing_units table without using *.
```sql
SELECT year,
       month,
       month_name,
       west,
       midwest,
       south,
       northeast
  FROM tutorial.us_housing_units
```
2. Write a query to select all of the columns in tutorial.us_housing_units and rename them so that their first letters are capitalized.
```sql
SELECT year AS "Year",
       month AS "Month",
       month_name AS "Month Name",
       west AS "West",
       midwest AS "Midwest",
       south AS "South",
       northeast AS "Northeast"
  FROM tutorial.us_housing_units
```
### LIMIT
3. Write a query that uses LIMIT command to restrict the result set to only 15 rows.
```sql
SELECT *
  FROM tutorial.us_housing_units
 LIMIT 15
```
### WHERE & Comparison Operators
4. Did the West Region ever produce more than 50,000 housing units in one month?
```sql
SELECT *
  FROM tutorial.us_housing_units
 WHERE west > 50
```
5. Did the South Region ever produce 20,000 or fewer housing units in one month?
```sql
SELECT *
  FROM tutorial.us_housing_units
 WHERE south <= 20
```
6. Write a query that only shows rows for which the month name is February.
```sql
SELECT *
  FROM tutorial.us_housing_units
 WHERE month_name = 'February'
```
7. Write a query that only shows rows for which the month_name starts with the letter "N" or an earlier letter in the alphabet.
```sql
SELECT *
  FROM tutorial.us_housing_units
 WHERE month_name <= 'N'
```
8. Write a query that calculates the sum of all four regions in a separate column.
```sql
SELECT year,
       month,
       south,
       west,
       midwest,
       northeast,
       south + west + midwest + northeast AS sum_four_regions
  FROM tutorial.us_housing_units
```
9. Write a query that returns all rows for which more units were produced in the West region than in the Midwest and Northeast combined.
```sql
SELECT *
  FROM tutorial.us_housing_units
 WHERE west > (midwest + northeast)
```
10. Write a query that calculates the percentage of all houses completed in the United States represented by each region. Only returns results from the year 2000 and later.
```sql
SELECT year,
       month,
       south/(south + west +  midwest + northeast)*100 AS south_percentage,
       west/(south + west +  midwest + northeast)*100 AS west_percentage,
       midwest/(south + west +  midwest + northeast)*100 AS midwest_percentage,
       northeast/(south + west +  midwest + northeast)*100 AS northeast_percentage
  FROM tutorial.us_housing_units
 WHERE year >= 2000
```
For the following queries, I'll be using data from [Billboard Music Charts](http://www.billboard.com/charts) It was collected in January 2014 and contains data from 1956 through 2013. The results in this table are the year-end results—the top 100 songs at the end of each year.

### LIKE
11. Write a query that returns all rows for which Ludacris was a member of the group.
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE group_name ILIKE '%ludacris%'
```
12. Write a query that returns all rows for which the first artist listed in the group has a name that begins with "DJ".
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE group_name LIKE 'DJ%'
```
### IN
13. Write a query that shows all of the entries for Elvis and M.C. Hammer.
```sql
-- After exploratory analysis using ILIKE I discovered that M.C. Hammer is
-- also listed as only 'Hammer' in the dataset.
SELECT *
  FROM tutorial.billboard_top_100_year_end
WHERE group_name IN ('M.C. Hammer', 'Hammer')
```
### Between
15. Write a query that shows all top 100 songs from January 1, 1985 through December 31, 1990.
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE year BETWEEN 1985 AND 1990
```
### IS NULL
16. Write a query that shows all of the rows for which song_name is null
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE song_name IS NULL
```
### AND
17. Write a query that surfaces all rows for top-10 hits for which Ludacris is part of the Group.
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE year_rank <= 10
   AND group_name ILIKE '%ludacris%'
```
18. Write a query that surfaces the top-ranked records in 1990, 200, 2010.
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE year_rank = 1
   AND year IN (1990, 2000, 2010)
```
19. Write a query that lists all songs from the 1960s with "love" in the title.
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE year BETWEEN 1960 AND 1969
   AND song_name ILIKE '%love%'
```
### OR
20. Write a query that returns all rows for top-10 songs that featured either Katy Perry or Bon Jovi.
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE year_rank <= 10
   AND (group_name ILIKE '%katy perry%' OR group_name ILIKE '%bon jovi%') 
```
21. Write a query that returns all songs with titles that contain the word "California" in either in 1970s or 1990s.
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE song_name ILIKE '%california%'
   AND (year BETWEEN 1970 AND 1979 OR year BETWEEN 1990 AND 1999) 
```
22. Write a query that lists all top-100 recordings that feature Dr. Dre before 2001 or after 2009.
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE group_name ILIKE '%dr. dre%'
   AND (year < 2001 OR year > 2009) -- Parentheses are a must.
```
### NOT
23. Write a query that returns all rows for songs that were on the charts in 2013 and do not contain the letter "a".
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE year = 2013
   AND song_name NOT ILIKE'%a%'
```
### ORDER BY
24. Write a query that returns all rows from 2012, ordered by song title from Z to A.
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE year = 2012
  ORDER BY song_name DESC
```
25. Write a query that returns all rows from 2010 ordered by rank, with artists ordered alphabetically for each song.
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE year = 2010
  ORDER BY year_rank, artist
```
26. Write a query that shows all rows for which T-PAIN was group member, ordered by rank on the charts, from lowest to highest rank (from 100 to 1).
```sql
SELECT *
  FROM tutorial.billboard_top_100_year_end
 WHERE group_name ILIKE '%t-pain%'
  ORDER BY year_rank DESC
```
27. Write a query that returns songs that ranked between 10 and 20 (inclusive) in 1993, 2003, 2013. Order the results by year and rank, and leave a comment on each of the `WHERE` clause to indicate what that line does.
```sql
SELECT * -- selects all columns
  FROM tutorial.billboard_top_100_year_end -- tells SQL where to export data from
 WHERE year_rank BETWEEN 10 AND 20 -- filters results based on the condition that the song ranked between 10 and 20 (inclusive)
   AND year IN (1993, 2003, 2013) -- filters results such that they were released in 1993, 2003, or 2013
  ORDER BY year, year_rank -- order results firstly by year, and then by rank; both in ascending order
```
**Final Thoughts**: This section gave me a solid foundation in SQL. I now feel confident working with basic queries, filtering results, applying logic, and manipulating columns. I'm excited to continue with the Intermediate section and explore how SQL can help answer more complex data questions.
